#!/usr/bin/env ruby

# A few helpful tips about the Rules file: #
# * The string given to #compile and #route are matching patterns for
#   identifiers--not for paths. Therefore, you can’t match on extension.
#
# * The order of rules is important: for each item, only the first matching #   rule is applied.
#
# * Item identifiers start and end with a slash (e.g. “/about/” for the file
#   “content/about.html”). To select all children, grandchildren, … of an
#   item, use the pattern “/about/*/”; “/about/*” will also select the parent,
#   because “*” matches zero or more characters.
preprocess do 
  def blog_json_index
    tmpl = <<ERB
<%=
  require 'json' 
  posts = @item[:posts].dup 
  posts.map! do |post|              
    {                                  
      path:          post.path,     
      title:         post[:title],        
      tags:          post[:tags],         
      created_at:    post[:created_at],   
      updated_at:    post[:updated_at],   
      summary:       post[:summary],      
      redirect:      post[:redirect],     
      redirect_path: post[:redirect_path],
      author:        (post[:author] || "Gabe Koss")
    }                                     
  end 
  JSON.generate(posts) 
%>
ERB

    post_chunk_size = 5
    posts = @items.reject { |i| !(i[:kind] == 'blog-post') }
    posts.sort_by! {|i| i[:created_at] } 
    posts.reverse! 

    posts_array = [] 
    posts.each_slice(post_chunk_size) { |slice| posts_array << slice }

    posts_array.each_with_index do |posts, index|
      @items << Nanoc::Item.new(
        tmpl,
        {extension: "erb",  posts: posts},
        "/api/v1/blog/#{index}.json"
      )
    end
  end

  def create_post_tag_pages

    tags = blog_post_tags_hash(@items)

    tmpl = <<ERB
  <% @item[:posts].each do |p| %>
    <p>
      <strong>
        <a href="<%= p.path %>">
          <%= p[:title] %>
        </a>
      </strong><br/> 
      <%= p[:summary] %>
    </p>
  <% end %>
ERB

    tags.each do |tag, posts|
      @items << Nanoc::Item.new(
        tmpl,
        {extension: "erb", title: tag.capitalize, tag: tag, posts: posts},
        "/tags/#{tag.gsub(/ /,'_')}"
      )
    end
  end

  create_post_tag_pages
  blog_json_index
end

compile '/stylesheet/' do
  # don’t filter or layout
end

compile '/blog/' do
 filter :erb
 layout 'default'
end

compile '/tags/*' do
 filter :erb
 layout 'default'
end

compile '/api/v1/blog/*' do
 filter :erb
end

compile '/sitemap/' do
  filter :erb
end

compile '*' do
  if item.binary? || %w{ pdf txt jpg png js css }.include?(item.attributes[:extension]) || item.identifier == '/sitemap/'
    # don’t filter binary items
  elsif item[:redirect] 
    layout 'redirect'
  elsif item.attributes[:extension] == 'md'
    filter :redcarpet, :options => {:fenced_code_blocks => true}
    layout 'default'
  else
    filter :erb
    layout 'default'
  end
end


route '/stylesheet/' do
  '/style.css'
end

route '/tags/*' do
  if item.identifier == '/tags/'
    '/tags/index.html'
  else 
    "/tags/#{item[:tag].gsub(/ /,'_')}/index.html"
  end
end

route '/api/v1/blog/*' do
  # remove trailing '/'
  item.identifier.gsub(/\/$/,'')
end


route '/blog/*' do
  begin
    y,m,d,slug = /([0-9]+)\-([0-9]+)\-([0-9]+)\-([^\/]+)/.match(item.identifier).captures
    "/blog/#{y}/#{m}/#{slug}/index.html"
  rescue
    "/blog/index.html"
  end
end

route '/sitemap/' do
  '/sitemap.xml'
end

route '*' do
  if item.binary? || %w{ pdf txt jpg png js css }.include?(item.attributes[:extension]) 

    # Write item with identifier /foo/ to /foo.ext
    item.identifier.chop + '.' + item[:extension] 
  else
    # Write item with identifier /foo/ to /foo/index.html
    item.identifier + 'index.html'
  end
end


layout '*', :erb
